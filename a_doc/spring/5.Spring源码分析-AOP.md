# 5.Spring源码分析-AOP

[TOC]

## 基本概念

### 切面aspect

所有具有Bean具同样规则，这个规则叫切面

### 连接点Joinpoint

规则的行为叫连接点

### 通知Advice

一量在调用过程中，满足连接点的规则，就会触发一个通知：调用代理写的代码

### 切入点Pointcut

具体的某个Bean的方法，够条件触发规则，叫切入点

### 目标对象Target Object

原始Bean

### AOP代理

生成的代理对象

## 通知类型

before advice

after advice

after return advice

around advice

after throwing advice

https://docs.spring.io/spring/docs/2.0.x/reference/aop.html#aop-ataspectj

### xml风格

#### `FooService.java`

```java
@Service
@Slf4j
public class FooService {
    public void update() throws RuntimeException {
        log.info("update something");
        throw new RuntimeException("RuntimeException");
    }

    public Integer add(Integer param) {

        log.info("add something {}",param);
        return param;
    }

    public void del() {
        log.info("del something");
    }

    public void query() {
        log.info("query something");
    }
}
```

#### `LogAspect.java`

```java
public class LogAspect {


    public void before(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        System.out.println(name + " before");
    }


    public void around(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        System.out.println(name + " around");
    }


    public void after(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        System.out.println(name + " after");
    }


    public void afterReturning(JoinPoint joinPoint, Object retVal) {
        System.out.println(retVal);
        String name = joinPoint.getSignature().getName();
        System.out.println(name + " afterReturning");
    }

    public void afterThrowing(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        System.out.println(name + " aferThrowing");
    }

}
```

#### `application.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <context:component-scan base-package="com.tom.demo"/>
    <context:annotation-config/>
    <aop:aspectj-autoproxy proxy-target-class="true"/>
    <bean id="logAspect" class="com.tom.demo.aspect.LogAspect"/>
    <aop:config>
        <aop:aspect ref="logAspect">
            <aop:pointcut id="myPointCut" expression="execution(* com.tom.demo.service..*(..))"/>
            <aop:before method="before" pointcut-ref="myPointCut"/>
            <aop:after method="after" pointcut-ref="myPointCut"/>
            <aop:after-throwing method="afterThrowing" pointcut-ref="myPointCut"/>
            <aop:after-returning method="afterReturning" returning="retVal" pointcut-ref="myPointCut"/>
            <aop:around method="around" pointcut-ref="myPointCut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

#### `LogAspectXmlTest.java`

```java
@ContextConfiguration(locations = {"classpath*:application.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
public class LogAspectXmlTest {
    @Autowired
    FooService fooService;

    @Test
    public void testAdd() {
        fooService.add(1);
    }

    @Test
    public void testUpdate() {
        fooService.update();
    }

    @Test
    public void testDel() {
        fooService.del();
    }

    @Test
    public void testQuery() {
        fooService.query();
    }
}
```

### 注解风格

#### `AnnotationLogAspect.java`

```java
@Component //声明是被Spring IOC来管理
@Aspect //声明是一个需要动态织入一个切面的类
@Slf4j
public class AnnotationLogAspect {
    @Pointcut(value = "execution(* com.tom.demo.service..*(..))")
    public void myPointCut() {
    }

    @Before("myPointCut()")
    public void before(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        log.info("{} before", name);
    }

    @Around("myPointCut()")
    public void around(ProceedingJoinPoint pjp) throws Throwable {

        String name = pjp.getSignature().getName();
        Object retVal = pjp.proceed();
        log.info("{} around, retVal:{}", name, retVal);


    }

    @After("myPointCut()")
    public void after(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        log.info("{} after", name);
    }

    @AfterReturning(value = "myPointCut()", returning = "retVal")
    public void afterReturning(JoinPoint joinPoint, Object retVal) {
        String name = joinPoint.getSignature().getName();
        log.info("{} afterReturning  retVal:{}", name, retVal);
    }

    @AfterThrowing(value = "myPointCut()", throwing = "e")
    public void afterThrowing(JoinPoint joinPoint, Exception e) {
        String name = joinPoint.getSignature().getName();
        log.info("{} afterThrowing {}", name, e.getMessage());
    }

}
```

#### `LogAspectAnnotationTest.java`

```java
@ComponentScan("com.tom.demo")
@EnableAutoConfiguration
@RunWith(SpringJUnit4ClassRunner.class)
public class LogAspectAnnotationTest {
    @Autowired
    FooService fooService;

    @Test
    public void testAdd() {
        fooService.add(1);
    }

    @Test
    public void testUpdate() {
        fooService.update();
    }

    @Test
    public void testDel() {
        fooService.del();
    }
    @Test
    public void testQuery() {
        fooService.query();
    }
}
```

### 切点语法

`execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)`

`execution(权限修饰符（public/protect/private可省略） 返回参数（void/其它类型，可以用*表示任意类型，必填） 包名类名（可省略）.方法名称（参数列表，必填) throws 异常类型（可省略）`



https://docs.spring.io/spring-framework/docs/2.0.x/reference/aop.html