# 1.spring源码分析

[TOC]

## 什么是spring

The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.

* 轻量级

* 面向Bean

* 松耦合

* 万能胶

* 设计模式

## 一切从Bean开始

### spring特性

使命：简化开发。

* 基于POJO的轻量量和最小侵入性编程
* 通过依赖注入和面向接口松耦合
* 基于切面和惯性进行声明式编程
* 通过切面和模板减少重复代码

### 面向Bean

Spring是面向Bean编程（Bean Oriented Programming BOP)的。

Spring提了IOC容器通过配置文件或注解的方式来管理对象之间的依赖关系。

控制反转（Dependency Injection DI或Dependency Lookup DL）: 不创建对象，但是描述创建它们的方式，在代码中不直接与对象和服务连接，但在配置文件中描述哪个组件需要哪一项服务。IOC容负责将这些联系在一起。

Before 

```java
A a=new A(); //自己主动实例化，控制权是自己
a.execute();
```

now

```java
@Autowire
A a //spring初始化的时候实例化，控制权交给了spring
a.execute();
```

> web容器   Servlet 
>
> IOC容器    Bean 

### 依赖注入

Inversion of control container(IOC container)

有了Bean实例后，就要使用依赖注入(对象的赋值)。

```java 
@Autowire InterfaceA a;//定义接口变量将实现类的实例赋值给a
@Resource("beanImpl") A a;//定义实现类变量将实现类的实例赋值给a
@Autowire A a;//根据类型将实例赋值给a
```

实例化的先后顺序

Spring注入方式：

setter

构造方法

强制赋值

> spring做三事件：1. 实例化对象 2. 搞清对象的关系 3. 将实例化的对象赋值

### 面向切面

面向切面编程，即AOP，是一种编程思想。允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。

核心规则：解耦，面向切面（规则）编程

如果模块有一定的规律性（共性问题），就可以用AOP的思想解决。

## spring架构设计

### 系统架构

### 依赖关系

### 常用的设计模式

#### 代理模式

特点：

1. 执行者，被代理人
2. 对于被代理人来说，事情要做，但不是自己做。
3. 要获取被代理人的资料

#####  静态代理

#####  动态代理

###### JDK 的动态代理

`InvocationHandler`

  ```java
  public interface Person {
      /**
       * 找女朋友
       */
      void findLove();
  }
  ```

  实现接口

  ```java
  public class TomPerson implements Person {
      @Override
      public void findLove() {
          System.out.println("Tom找到女朋友了");
      }
  }
  ```

  测试

  ```java
  public static void main(String[] args) throws IOException {
      System.out.println("找女朋友自己搞定");
      Person p = new TomPerson();
      p.findLove();
  }
  ```

  通过代理来实现

  ```java
  public class Matchmaker implements InvocationHandler {
      private Person target;
  
      public Object getInstance(Person p) {
          this.target = p;
          Class<? extends Person> clazz = p.getClass();
          System.out.println(p.getClass());
          return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);
      }
  
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          System.out.println("我是媒婆，海选女朋友");
          method.invoke(this.target,args);
          return proxy;
      }
  }
  ```

  测试

  ```java
  public static void main(String[] args) throws IOException {
      System.out.println("找女朋友通过媒婆来搞定");
      Person p2 = (Person) new Matchmaker().getInstance(new TomPerson());
      System.out.println(p2.getClass());
      p2.findLove();
  }
  ```

输出

```cmd
class com.example.demo.proxy.jdk.TomPerson
class com.sun.proxy.$Proxy0
我是媒婆，海选女朋友
Tom找到女朋友了
```

> JDK动态代理必须要写接口
>
> 查看生成的字节码文件
>
> ```java
> Person p2 = (Person) new Matchmaker().getInstance(new TomPerson());
> //生成的代理字节码文件
> byte[] bytes = ProxyGenerator.generateProxyClass("$proxy0", new Class[]{p2.getClass()});
> FileOutputStream inputStream = new FileOutputStream("./$proxy0.class");
> inputStream.write(bytes);
> inputStream.close();
> ```

###### 手写动态代理

重写实现调用`TomInvocationHandler`

  ```java
  public interface TomInvocationHandler {
      Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable;
  }
  ```

 代理类`TomProxy`

  ```java
  import javax.tools.JavaCompiler;
  import javax.tools.JavaFileObject;
  import javax.tools.StandardJavaFileManager;
  import javax.tools.ToolProvider;
  import java.io.File;
  import java.io.FileWriter;
  import java.io.IOException;
  import java.lang.reflect.Constructor;
  import java.lang.reflect.InvocationTargetException;
  import java.lang.reflect.Method;
  
  /**
   * 生成代理类，执行原接口方法
   *
   * @author TomLuo
   * @date 2019/8/18
   */
  public class TomProxy {
      public static final String LN = "\r\n";
      public static final String $_PROXY_NAME = "$Proxy0";
  
      public static Object newProxyInstance(TomClassLoader loader,
                                            Class<?>[] interfaces,
                                            TomInvocationHandler h) {
          //1.生成源代码
          String codes = generateCodes(interfaces[0]);
          //2.将生成的源代码保存到磁盘$Proxy0.java
          String path = TomProxy.class.getResource("").getPath();
          File f = new File(path + $_PROXY_NAME + ".java");
          FileWriter fw = null;
          try {
              fw = new FileWriter(f);
              fw.write(codes);
              fw.flush();
              fw.close();
              fw.close();
              //3.编译源代码生成.class文件
              JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
              StandardJavaFileManager manager = compiler.getStandardFileManager(null, null, null);
              Iterable<? extends JavaFileObject> iterable = manager.getJavaFileObjects(f);
              JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, null, null, iterable);
              task.call();
              manager.close();
              //4.class动态加载到JVM
              Class<?> aClass = loader.findClass($_PROXY_NAME);
              //5.返回被代理后的代理对象
              Constructor<?> constructor = aClass.getConstructor(TomInvocationHandler.class);
              return constructor.newInstance(h);
          } catch (IOException e) {
              e.printStackTrace();
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          } catch (NoSuchMethodException e) {
              e.printStackTrace();
          } catch (IllegalAccessException e) {
              e.printStackTrace();
          } catch (InstantiationException e) {
              e.printStackTrace();
          } catch (InvocationTargetException e) {
              e.printStackTrace();
          } finally {
              f.delete();
          }
          return null;
      }
  
      private static String generateCodes(Class<?> anInterface) {
          StringBuffer stringBuffer = new StringBuffer();
          stringBuffer.append("package com.example.demo.proxy.jdk.manual;" + LN);
          stringBuffer.append("import java.lang.reflect.Method;" + LN);
          stringBuffer.append("public final class " + $_PROXY_NAME + " implements " + anInterface.getName() + " {" + LN);
          String invocationHandlerName = TomInvocationHandler.class.getName();
          stringBuffer.append(invocationHandlerName + " h;" + LN);
          stringBuffer.append(" public " + $_PROXY_NAME + "(" + invocationHandlerName + " h)  {\n" + LN +
                  "        this.h=h;\n" + LN +
                  "    }" + LN);
          for (Method m : anInterface.getMethods()) {
              stringBuffer.append("@Override" + LN);
              stringBuffer.append("public final " + m.getReturnType().getName() + " " + m.getName() + "()  {" + LN);
              stringBuffer.append("try{" + LN);
              stringBuffer.append(" Method m=" + anInterface.getName() + ".class.getMethod(\"" + m.getName() + "\");" + LN);
              stringBuffer.append(" this.h.invoke(this, m, (Object[])null);" + LN);
              stringBuffer.append("}catch(Throwable e){e.printStackTrace();}" + LN);
              stringBuffer.append("}" + LN);
          }
          stringBuffer.append("}" + LN);
          return stringBuffer.toString();
      }
  }
  
  ```
载入类`TomClassLoader.java`
 ```java
public class TomClassLoader extends java.lang.ClassLoader {
    public static final String PACKAGE_NAME = TomProxy.class.getPackage().getName();
    File baseDir;

    public TomClassLoader() {
        String path = TomClassLoader.class.getResource("").getPath();
        this.baseDir = new File(path);
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String className = PACKAGE_NAME + "." + name;
        if (this.baseDir.exists()) {
            File classFile = new File(this.baseDir, name.replaceAll("\\.", File.separator) + ".class");
            if (classFile.exists()) {
                FileInputStream inputStream = null;
                ByteArrayOutputStream outputStream = null;
                try {
                    inputStream = new FileInputStream(classFile);
                    outputStream = new ByteArrayOutputStream();
                    byte[] buf = new byte[1024];
                    int len;
                    while ((len = inputStream.read(buf)) > 0) {
                        outputStream.write(buf, 0, len);
                    }
                    return defineClass(className, outputStream.toByteArray(), 0, outputStream.size());
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    IOUtils.closeQuietly(inputStream);
                    IOUtils.closeQuietly(outputStream);
                }
            }
        }
        return null;
    }
}
 ```



 媒婆代理`TomMatchmaker`

  ```java
  public class TomMatchmaker implements TomInvocationHandler {
    private Person target;
    public Object getInstance(Person p) {
        this.target = p;
        Class<? extends Person> clazz = p.getClass();
        System.out.println(p.getClass());
        return TomProxy.newProxyInstance(new TomClassLoader(), clazz.getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("我是手写代理媒婆，海选女朋友");
        method.invoke(this.target,args);
        return proxy;
    }
}
  ```

输出

```cmd
class com.example.demo.proxy.jdk.TomPerson
class com.example.demo.proxy.jdk.manual.$Proxy0
我是手写代理媒婆，海选女朋友
Tom找到女朋友了
```



> 总结：代理实质，字节码重组

######  `CGLib`动态代理 

`cglig.jar` （code generation library代码生成库）

`asm.jar`（assembly,装配）

编写被代理类

```java
public class TomPerson {
    public void findLove() {
        System.out.println("Tom找到cglib女朋友了");
    }
}
```

CGLib代理类

```java
public class CGLibMatchmaker implements MethodInterceptor {

    @Override
    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("我是媒婆，海选女朋友");
        return proxy.invokeSuper(target, args);
    }

    public Object getInstance(Object target) {
        Enhancer enhancer = new Enhancer();
        Class<?> clazz = target.getClass();
        System.out.println(clazz);
        //将目标类设置成父类
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        //返回子类作为代理对象
        return enhancer.create();
    }
}
```

调用

```java
public class TestCGLib {
    public static void main(String[] args) {
        TomPerson person= (TomPerson)new CGLibMatchmaker().getInstance(new TomPerson());
        System.out.println(person.getClass());
        person.findLove();
    }
}
```

输出

```cmd
class com.example.demo.cglib.TomPerson
class com.example.demo.cglib.TomPerson$$EnhancerByCGLIB$$239ce284
我是媒婆，海选女朋友
Tom找到cglib女朋友了
```

#### 工厂模式

* 简单工厂 
* 工厂方法
* 抽象工厂

#### 单例模式

#### 委派模式

#### 策略模式

#### 原型模式（模板模式）

