# 9.分布式协调服务-zookeeper之zkClient和Curator

## 权限控制模式

schema：授权对象

ip   : 192.168.1.1

Digest : username:password

world : 开放式的权限控制模式，数据节点的访问权限对所有用户开放。 world:anyone

super ：超级用户，可以对zookeeper上的数据节点进行操作

## 连接状态

Event.KeeperState.Expired  在一定时间内客户端没有收到服务器的通知， 则认为当前的会话已经过期了。

Event.KeeperState.Disconnected 断开连接的状态

Event.KeeperState.SyncConnected 客户端和服务器端在某一个节点上建立连接，并且完成一次version、zxid同步

Event.KeeperState.authFailed 授权失败

## 事件类型

Event.EventType.NodeCreated 当节点被创建的时候，触发

Event.EventType.NodeChildrenChanged  表示子节点被创建、被删除、子节点数据发生变化

Event.EventType.NodeDataChanged  节点数据发生变化

Event.EventType.NodeDeleted    节点被删除

Event.EventType.None  客户端和服务器端连接状态发生变化的时候，事件类型就是None

## zkClient

### `pom.xml`增加依赖

```xml
<dependency>
    <groupId>com.101tec</groupId>
    <artifactId>zkclient</artifactId>
    <version>0.11</version>
</dependency>
```

### `ZkClientDemo.java`

```java
public class ZkClientDemo {
    public static void main(String[] args) {
        ZkClient zkClient = new ZkClient(Constant.CONNECT, 40000);
        System.out.println(zkClient + " 联接成功");
        // 递归创建路径的功能
        String path = "/zkclient1";
        String path1 = "/zkclient2";
        String path2 = path1 + "/zkclient2-1";
        zkClient.createEphemeral(path, "123");
        zkClient.createPersistent(path2, true);
        //获取子节点
        List<String> children = zkClient.getChildren(path1);
        System.out.println("获取子节点：" + JSON.toJSONString(children, true));
        //事件订阅
        zkClient.subscribeDataChanges(path, new IZkDataListener() {
            @Override
            public void handleDataChange(String s, Object o) throws Exception {
                System.out.println("事件监听->数据变化的节点为：" + s + "-->数据变化的值为：" + o);
            }

            @Override
            public void handleDataDeleted(String s) throws Exception {
                System.out.println("事件监听->删除的节点为：" + s);
            }
        });
        zkClient.subscribeChildChanges(path1, new IZkChildListener() {
            @Override
            public void handleChildChange(String s, List<String> list) throws Exception {
                System.out.println("事件监听->子节点变化的节点为：" + s + "-->变化的子集点：" + JSON.toJSONString(list));
            }
        });
        zkClient.writeData(path, "123456");
        zkClient.createEphemeral(path1 + "/zkclient2-2");
        // 删除功能
        boolean delete = zkClient.delete(path);
        if (delete) {
            System.out.println("删除" + path + "成功！");
        }
        delete = zkClient.deleteRecursive("/zkclient2");
        if (delete) {
            System.out.println("删除" + path1 + "成功！");
        }
    }
}
```

## curator

Curator本身是Netflix公司开源的zookeeper客户端；

curator提供了各种应用场景的实现封装

curator-framework 提供了fluent风格api

curator-replice   提供了实现封装

### `pom.xml`增加依赖

```xml
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-framework</artifactId>
    <version>4.1.0</version>
</dependency>
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-recipes</artifactId>
    <version>4.1.0</version>
</dependency>
```

### `CuratorSessionDemo.java`

创建session的两种方式

* 正常方式
* fluent方式

```java
public class CuratorSessionDemo {
    public static void main(String[] args) {
        //创建session的两种方式
        //正常方式
        CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(CONNECT, 4000, 5000, new ExponentialBackoffRetry(1000, 3));
        curatorFramework.start();
        System.out.println(curatorFramework.getState());
        //fluent方式
        CuratorFramework curatorFramework1 = CuratorFrameworkFactory.builder().connectString(CONNECT).sessionTimeoutMs(4000).sessionTimeoutMs(5000).retryPolicy(new ExponentialBackoffRetry(1000, 3)).build();
        curatorFramework1.start();
        System.out.println(curatorFramework1.getState());
    }
}
```

### curator连接的重试策略

ExponentialBackoffRetry衰减重试 

RetryNTimes 指定最大重试次数

RetryOneTime 仅重试一次

RetryUnitilElapsed 一直重试知道规定的时间

## zookeeper的实际应用场景

zookeeper能够实现哪些场景

* 订阅发布

    watcher机制

    统一配置管理（disconf）

* 分布式锁

    redis 

    zookeeper(临时有序节点及watcher)

    数据库  

* 负载均衡

* ID生成器

* 分布式队列

* 统一命名服务

* master选举