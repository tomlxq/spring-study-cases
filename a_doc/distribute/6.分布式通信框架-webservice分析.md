分布式通信框架-webservice分析

## 什么是webservice
webservice也可以叫xml web service webservice, 轻量级的独立的通讯技术

1.	基于web的服务：服务端提供的服务接口让客户端访问
2.	跨平台、跨语言的整合方案
为什么要使用webservice
跨语言调用的解决方案

什么时候要去使用webservice
电商平台，订单的物流状态。 
 .net实现的webservice服务接口

## webservice中的一些概念
### WSDL(web service definition language  webservice 定义语言)
webservice服务需要通过wsdl文件来说明自己有什么服务可以对外调用。并且有哪些方法、方法里面有哪些参数
wsdl基于XML（可扩展标记语言）去定义的

1. 对应一个.wsdl的文件类型

2. 定义了webservice的服务器端和客户端应用进行交互的传递数据和响应数据格式和方式

3. 一个webservice对应唯一一个wsdl文档
### SOAP（simple object access protocal简单对象访问协议）

http+xml
webservice通过http协议发送和接收请求时， 发送的内容（请求报文）和接收的内容（响应报文）都是采用xml格式进行封装
这些特定的HTTP消息头和XML内容格式就是SOAP协议

1. 一种简单、基于HTTP和XML的协议

2. soap消息：请求和响应消息

3. http+xml报文

### SEI（webservice endpoint interface webservice的终端接口）
webservice服务端用来处理请求的接口，也就是发布出去的接口。

## 开发一个webservice的实例

### 服务端

#### `ISayHello.java`

```java
/**
 * SE和SEI的实现类
 *
 * @author TomLuo
 * @date 2019/12/7
 */
@WebService
public interface ISayHello {
    /**
     * SEI中的方法
     * @param hello
     * @return
     */
    @WebMethod
    String sayHello(String hello);
}
```

#### `SayHello.java`

```java
@WebService
public class SayHello implements ISayHello {

    @Override
    public String sayHello(String name) {
        return "hello,"+name;
    }
}
```

#### `Bootstrap.java`

```JAVA
public class Bootstrap {
    public static void main(String[] args) {
        ISayHello sayHello = new SayHello();
        Endpoint.publish("http://localhost:9000/hello",sayHello);
        System.out.println("发布webservice成功了");
    }
}
```

### 客户端

#### 生成客户端代码

`${JAVA_HOME}\bin\wsimport -keep -p com.tom.webserviceclient  http://localhost:9000/hello?wsdl`

#### `Bootstrap.java`

```java
public class Bootstrap {
    public static void main(String[] args) throws MalformedURLException {
       SayHelloService sayHelloService = new SayHelloService();
        SayHello sayHelloPort = sayHelloService.getSayHelloPort();
        System.out.println(sayHelloPort.sayHello("rose"));
    }
}
```

输出

`hello,rose`

## 分析WSDL文档

![1575708574981](img/1575708574981.png)

* Types标签

  定义整服务端的数据报文

  * Schema标签

    ```xml
    <types>
    <xsd:schema>
    <xsd:import namespace="http://webservice.tom.com/" schemaLocation="http://localhost:9000/hello?xsd=1"/>
    </xsd:schema>
    </types>
    ```

* Message

  ```xml
  <message name="sayHello">
  <part name="parameters" element="tns:sayHello"/>
  </message>
  <message name="sayHelloResponse">
  <part name="parameters" element="tns:sayHelloResponse"/>
  </message>
  ```

  定义了在通信中使用的消息的数据结构

*  portType 

  ```xml
  <portType name="SayHello">
  <operation name="sayHello">
  <input wsam:Action="http://webservice.tom.com/SayHello/sayHelloRequest" message="tns:sayHello"/>
  <output wsam:Action="http://webservice.tom.com/SayHello/sayHelloResponse" message="tns:sayHelloResponse"/>
  </operation>
  </portType>
  ```

  定义服务器端的SEI

  input/output表示输入/输出数据

*  binding 

  ```xml
  <binding name="SayHelloPortBinding" type="tns:SayHello">
  <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
  <operation name="sayHello">
  <soap:operation soapAction=""/>
  <input>
  <soap:body use="literal"/>
  </input>
  <output>
  <soap:body use="literal"/>
  </output>
  </operation>
  </binding>
  ```

  1. type属性： 引用portType 

     `<soap:binding style="document"> `

  2. operation : 指定实现方法

  3. input/output 表示输入和输出的数据类型

     literal表示文本

*  service 

  ```xml
  <service name="SayHelloService">
  <port name="SayHelloPort" binding="tns:SayHelloPortBinding">
  <soap:address location="http://localhost:9000/hello"/>
  </port>
  </service>
  ```

  service： 服务器端的一个webservice的容器

  name属性： 指定客户端的容器类

  `soap:address` 当前webservice的请求地址

![1575709118002](img/1575709118002.png)

![1575709170701](img/1575709170701.png)

### SOAP UI的报文

#### 发送的报文

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://webservice.tom.com/">
   <soapenv:Header/>
   <soapenv:Body>
      <web:sayHello>
         <!--Optional:-->
         <arg0>阿婆</arg0>
      </web:sayHello>
   </soapenv:Body>
</soapenv:Envelope>
```

#### 接收的报文

```xml
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
   <S:Body>
      <ns2:sayHelloResponse xmlns:ns2="http://webservice.tom.com/">
         <return>hello,阿婆</return>
      </ns2:sayHelloResponse>
   </S:Body>
</S:Envelope>
```

## 其它的web service

Axis/Axis2

apache开源的webservice工具

### CXF

Celtix+Xfire 。 用的很广泛，因为集成到了spring

### Xfire

高性能的Webservice

HTTP+JSON (新的webservice)

HTTP+XML

## spring cxf+REST实现一个webservice服务

springmvc+REST实现的新webservice 

linux： centos7; vm可以copy 设置一个备份点

jdk、tomcat

RMI、 http协议/https、webservice、 TCP协议、UDP协议、 

socket编程、bio /nio模型、分布式架构、集群、架构演进过程

## Issuers

### 两个类具有相同的 XML 类型名称。请使用 @XmlType.name 和 @XmlType.namespace 为类分配不同的名称

说明：

此问题是在webservice服务通过wsimport指令生成客户端之后，编写测试代码测试时的报错。

问题出现原因：

由于生成客户端时，没有指定路径，因此默认生成的路径还是原先服务端提供的路径。

解决办法：

通过wsimport指令指定路径生成客户端，然后重新加载。
`${JAVA_HOME}\bin\wsimport -keep -p com.tom.webserviceclient  http://localhost:9000/hello?wsdl`